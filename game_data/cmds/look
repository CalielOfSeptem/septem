inherit command
c = command.new()
c:SetVerb("look")

-- o is the base_entity from which the command originated.  Cmd is the command text.  Note that the verb
-- which initiated the command will be the first element in cmd.  Ex/ > look, cmd="look", >look chest, cmd = "look chest"

function command:execute_command ( o, cmd )
	--print( 'Type of o = ' .. type(o) )  o will be of user_data
	p = player_cast(o)
	if p ~= nil then
		-- lets see what room the player/npc is in..
		-- there are two ways, through GetEnvironment, or through GetRoom
		-- GetEnvironment requires a cast as its generic to all game items/players.
		-- GetRoom does not as its already a room object ptr
		-- example: env = room_cast(p:GetEnvironment())
		env = p:GetRoom()

		if env ~= nil then
			s = FormatRoom(env)
			--p:SendToEntity('[' .. env:GetTitle() .. ']')
			--p:SendToEntity('\r\n')
			p:SendToEntity(s .. '\r\n')
		end	
	end
end

function string:split( inSplitPattern, outResults )
  if not outResults then
    outResults = { }
  end
  local theStart = 1
  local theSplitStart, theSplitEnd = string.find( self, inSplitPattern, theStart )
  while theSplitStart do
    table.insert( outResults, string.sub( self, theStart, theSplitStart-1 ) )
    theStart = theSplitEnd + 1
    theSplitStart, theSplitEnd = string.find( self, inSplitPattern, theStart )
  end
  table.insert( outResults, string.sub( self, theStart ) )
  return outResults
end

function FormatRoom(r)
	s = "[" .. r:GetTitle() .. "]\r\n"
	s = s .. r:GetDescription() .. "\r\n"
	s = s .. "Obvious paths: "
	exits = r:GetExits()
	for i = 1, #exits do
		local myTable = exits[i]:GetExit():split("|")
		str = myTable[1]
		str = str:lower()
		if i ~= #exits then
			str = str .. ', '

		else
			str = str .. '.' 
		end
		s = s .. str
	end
	
	return s

end
